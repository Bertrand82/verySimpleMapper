package atom.tools.very.simple.generator.mapper;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.TypeSpec;

public class GeneratorMapper {

	private List<ClassPair> listClassPairs = new ArrayList<ClassPair>();
	private File dirOutput = new File("GENERATED_COMPARATOR");
	private ClassPair classPair;
	private JavaPoetWriter javaPoetWritter;
	private static String packageName = "atom.generated.mapper";
	
	
	public GeneratorMapper(String class1, String class2,File dirOut)  throws ClassNotFoundException{
		this(getClassByName(class1), getClassByName(class2),dirOut);
	}
	

	public GeneratorMapper(final Class<?> clazzOut, final Class<?> clazzIn) throws ClassNotFoundException {
		this(clazzOut,clazzIn,new File("GENERATED_COMPARATOR"));
	}
		public GeneratorMapper(final Class<?> clazzOut, final Class<?> clazzIn, File dirOut2) throws ClassNotFoundException {
		this.dirOutput= dirOut2;
		dirOutput.mkdirs();
		final ClassPair cp = new ClassPair(clazzIn, clazzOut);
		classPair = cp;
		processClass(cp);

		javaPoetWritter = new JavaPoetWriter(dirOutput);
		javaPoetWritter.write(getJavaFileGenerator());
		System.err.println("Done  dirOutput exists  : " + dirOutput.exists() + " | path  : " + dirOutput.getAbsolutePath());
	}

	private static Class  getClassByName(String class2) throws ClassNotFoundException {
		return GeneratorMapper.class.getClassLoader().loadClass(class2);
		
	}



	private void processClass(final ClassPair cPair) throws ClassNotFoundException {

		listClassPairs.add(cPair);
		cPair.process();
		for (final ClassPair cp : cPair.getListClassPair()) {
			if (!isProcessed(cp)) {
				processClass(cp);
			}
		}
	}
	
	

	private boolean isProcessed(ClassPair cp) {
	   for(ClassPair c : this.listClassPairs) {
		   if(c.equalsAsymetrique(cp)) {
			   return true;
		   }
	   }
		return false;
	}

	public JavaFile getJavaFileGenerator() {

		final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(getClassMapperName()).addModifiers(Modifier.PUBLIC);

		String comment = "Cette Class permet de de fiare du mappage entre les 2 classes suivantes \n";
		comment += "In : \t" + classPair.classIn.getName() + "\n";
		comment += "Out: \t" + classPair.classOut.getName() + "\n";

		List<MappageFailure> listFailure = getListMappageFailure();
		for (MappageFailure mp : listFailure) {
			comment += "\n " + mp;
		}
		comment += "\n\n ";
		classBuilder.addJavadoc(comment);
		classBuilder.addMethod(mainMapMethod_1());
		classBuilder.addMethod(mainMapMethod_2());
		
		for (final ClassPair cp : listClassPairs) {
			classBuilder.addMethod(cp.getMethodsMapper_1().getMethodMapper());
			
			classBuilder.addMethod(cp.getMethodsMapper_2().getMethodMapper());
		}

		final TypeSpec customClassMapper = classBuilder.build();
		final JavaFile.Builder javaFileBuilder = JavaFile.builder(packageName, customClassMapper).indent("    ");

		javaFileBuilder.addFileComment("Generated by " + this.getClass().getName());
		final JavaFile javaFile = javaFileBuilder.build();
		return javaFile;
	}

	public File getDirOutput() {
		return dirOutput;
	}

	private List<MappageFailure> getListMappageFailure() {
		List<MappageFailure> list = new ArrayList<MappageFailure>();
		for (final ClassPair cp : listClassPairs) {
			list.addAll(cp.getMethodsMapper_1().getListMappageFailure());
			list.addAll(cp.getMethodsMapper_2().getListMappageFailure());
		}
		return list;
	}

	private MethodSpec mainMapMethod_1() {
		return mainMapMethod(classPair);
	}
	private MethodSpec mainMapMethod_2() {
		return mainMapMethod(classPair.getSymetrique());
	}
	private MethodSpec mainMapMethod(ClassPair classPair ) {
		final MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("map").
				addParameter(classPair.classIn, "in").
				returns(classPair.classOut).
				addModifiers(Modifier.PUBLIC).
				addModifiers(Modifier.STATIC);
		AbstracMethodMapper gmm = this.classPair.getMethodsMapper_1();
		methodBuilder.addStatement("return " + gmm.getMethodName() + "(in)");
		return methodBuilder.build();
	}
	
	private String getClassMapperName() {
		if (classPair.classIn.getSimpleName().equals(classPair.classOut.getSimpleName())) {
			return "Mapper_" + classPair.classIn.getSimpleName();
		} else {
			return "Mapper_" + classPair.classIn.getSimpleName() + "_to_" + classPair.classOut.getSimpleName();
		}
	}
	
}
